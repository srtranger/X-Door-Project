;   Модуль обеспечения работы с NVRAM
;
;
;-------------------------------------------------------------------
; Сохраняет в NVRAM умалчиваемые переменные конфигурации.
;
;
Write_Var_Preset:
                Power   On
                NVRAM   On
                mov     r2,#20
                call    r2x1ms

                mov     dptr,#NV_Var    ; dptr = адрес таблицы перем-х в NVRAM
                mov     r6,#0           ; номер (смещение в табл ROM) текущей
                                        ; умалчиваемой переменной
                mov     r7,#6           ; их количество
loop$
                push    dpl
                push    dph
                mov     a,r6
                mov     dptr,#Var_preset ; dptr = адрес таблицы в ROM - умалчиваемые
                movc    a,@a+dptr        ; получить текущее значение переменн.
                pop     dph
                pop     dpl

                call    WriteByte        ; записать её в NVRAM
                inc     dptr             ; инкр. указатель табл. в NVRAM
                inc     r6               ; инкр. смещение в ROM (номер)
                djnz    r7,loop$         ; всё?

                NVRAM   Off
                Power   Off
                ret
;-------------------------------------------------------------------
;  просматривает массив кодов карточек в NVRAM и сравнивает их с
;  принятым ридером в буфер (data_buffer). При совпадении хотя бы
;  одного из кодов с принятым выставляет флаг C. Иначе флаг сброшен.
;  Возвращает в  A - условный номер карточки.

CodeCompare:
                Power   On               ; вкл. питание NVRAM
                mov     dptr,#NCards     ; читать кол-во карточек, которым...

                mov     r2,#20           ; задержка на 20 мс
                call    r2x1ms           ;

                call    ReadByte         ; ... система обучена
                dec     a                ; кол-во -1 = r7
                mov     r7,a             ; сохранить кол-во - 1 в r7
                mov     r1,#data_buffer  ; в r1 - указатель на буфер приёма
                mov     r5,#0h           ; в r5 - текущий номер карточки
                                         ; начало таблицы карточек (смещение)
CardLoop$
                call    GetAdr           ; вычислить начальный
                                         ; адрес в NVRAM для r5
                mov     r4,#8            ; ожидается читать 8 байт из NVRAM
                                         ; 8 байт - длина кода карточки
loop$                              ; ЦИКЛ ЧТЕНИЯ ОЧЕРЕДНОЙ КАРТОЧКИ ИЗ NVRAM
                call    ReadByte         ; читать байт из NVRAM
                mov     b,@r1            ; читать байт из буфера приёма кода
                cjne    a,b,bad$         ; сравнить коды, если не равны ....
                inc     r1               ; инкремент указателей, если
                inc     dptr             ; очередные байты идентичны
                djnz    r4,loop$         ; цикл, если не все байты перебраны
                setb    c                ; КОДЫ ОК - установлен флаг С
                mov     a,r5             ; в A - условный номер совпавшей
exit$                                    ; карточки
                Power   Off              ; выкл. питание NVRAM
                ret                      ; ВОЗВРАТ

bad$                                     ; .... Проверить, все ли карточки
                mov     b,r7
                mov     a,r5
                cjne    a,b,card_inc$    ; перебраны?
card_inc$       jc      lowest$
                clr     c
                jmp     exit$            ; если да - на ВЫХОД со сброшенным
lowest$                                  ; флагом С . A - не определён
                inc     r5               ; если нет - взять очередной номер
                jmp     CardLoop$        ; карточки и повторить для неё сравнение


;-----------------------------------------------------------------
;        вычисление начального адреса для текущей карточки
;        её номер на входе в r5. На выходе - dptr = искомый адрес
;        Начало таблицы в NVRAM - *Adr=000h*

GetAdr:
               push     a               ; Начальный адрес вычисляется
               push     b               ;
               mov      a,#08h          ;       по формуле
               mov      b,r5            ;        Adr= N*8,
               mul      ab              ; где
               mov      dpl,a           ; Adr - начальный aдрес карточки в
               mov      dph,b           ;       NVRAM
               pop      b               ;   N - условный номер карточки (r5)
               pop      a               ;   8 - константа
               ret



;--------------------------------------------
; сохраняет принятый код карточки, находящийся в буфере приёма, в NVRAM
; по адресу, определяемому условным номером карточки (r5).
; Начальный адрес определяется как Adr= r5*8 в процедуре GetAdr
CodeSave:
               Power    On                 ; вкл. питание NVRAM
               NVRAM    On                 ; выкл. защиту от записи

               call     GetAdr             ; dptr = начальный адрес текущей
               mov      r1,#data_buffer    ; карточки, r1 - указатель на
                                           ; буфер приёмника
               mov      r4,#8              ; кол-во сохраняемых байт
loop$                                      ; ЦИКЛ СОХРАНЕНИЯ КОДА В NVRAM
               mov      a,@r1              ; в А - текущий байт из буфера приёма
               call     WriteByte          ; записать байт в NVRAM
               inc      r1                 ; инкремент указатея буфера приёма
               inc      dptr               ; инкремент адреса в NVRAM
               djnz     r4,loop$           ; все байты кода карточки?
                                           ; если да - код сохранён
               Power    Off                ; выкл. питание NVRAM
               NVRAM    Off                ; вкл. защиту от записи в NVRAM

               ret


